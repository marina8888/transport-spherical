def get_rops(self, gas, f, species=None):
    """
    Getting the integral ROP across the domain for each reaction
    :param gas:
    :param f:
    :param species:
    :return:
    """
    species_ix = gas.species_index(species)

    # intialise integral_ROP list:
    int_rop = []
    net_stoich_coeffs = (f.gas.product_stoich_coeffs() - f.gas.reactant_stoich_coeffs())

    for r in range(len(gas.reaction_equations())):
        ropr = f.net_rates_of_progress[r, :]  # put grids in here [r, 550:750]
        rop = net_stoich_coeffs[species_ix, r] * ropr
        x = f.grid[:]  # put grids in here [550:750]
        temp_r = np.trapz(y=rop, x=x)  # use numpy trapezium rule to calculate integral rop values:
        int_rop.append(temp_r)
    rops = pd.DataFrame(index=gas.reaction_equations(), columns=["base_case"], data=int_rop)
    rops['x'] = x
    return rops


def get_sensitivities(self, gas, f, species=None):
    """

    :param gas: gas object generated by ct.Solution()
    :param f: flame from previous run
    :param species: species of interest to analyse
    :return:
    """

    Su = None
    Su0 = None
    if species == None:
        # take lbv sense by default:
        Su0 = f.velocity[0]
    else:
        print(f"doing sensitivity analysis for {species}")
        # take species at outlet:
        species_ix = gas.species_index(species)
        Su0 = f.X[species_ix, -1]

    # Create a dataframe to store sensitivity-analysis data
    sensitivities = pd.DataFrame(
        index=gas.reaction_equations(), columns=["base_case"]
    )

    for m in range(gas.n_reactions):
        gas.set_multiplier(1.0)  # reset all multipliers
        gas.set_multiplier(1 + self.pertubation, m)  # perturb reaction m

        # Always force loglevel=0 for this
        # Make sure the grid is not refined, otherwise it won't strictly
        # be a small perturbation analysis
        # Turn auto-mode off since the flame has already been solved
        f.solve(loglevel=0, refine_grid=False, auto=False)

        # new values with pertubation:
        if species == None:
            # take lbv sense by default:
            Su = f.velocity[0]
        else:
            print(f"doing sensitivity analysis for {species}")
            # take species at outlet:
            species_ix = gas.species_index(species)
            Su = f.X[species_ix, -1]

        sensitivities.iloc[m, 0] = (Su - Su0) / (Su0 * self.pertubation)
    # return mech to normal:
    gas.set_multiplier(1.0)

    return sensitivities